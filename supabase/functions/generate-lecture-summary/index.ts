
import "https://deno.land/x/xhr@0.1.0/mod.ts";
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.21.0';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { lectureId, part } = await req.json();
    const openAIApiKey = Deno.env.get('OPENAI_API_KEY');
    
    if (!openAIApiKey) {
      throw new Error('OpenAI API key not found');
    }

    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Fetch lecture content
    const { data: lecture, error: lectureError } = await supabaseClient
      .from('lectures')
      .select('*')
      .eq('id', lectureId)
      .single();

    if (lectureError || !lecture?.content) {
      console.error('Error fetching lecture:', lectureError);
      throw new Error('Lecture content not found');
    }

    // Fetch AI configuration
    const { data: aiConfig, error: aiConfigError } = await supabaseClient
      .from('lecture_ai_configs')
      .select('*')
      .eq('lecture_id', lectureId)
      .single();

    if (aiConfigError) {
      console.log('No AI config found, using defaults');
    }

    // Use AI config values or defaults
    const temperature = aiConfig?.temperature ?? 0.7;
    const creativityLevel = aiConfig?.creativity_level ?? 0.5;
    const detailLevel = aiConfig?.detail_level ?? 0.6;
    const customInstructions = aiConfig?.custom_instructions || '';
    const contentLanguage = aiConfig?.content_language || 'English';

    console.log('Using AI config:', {
      temperature,
      creativityLevel,
      detailLevel,
      contentLanguage,
      hasCustomInstructions: !!customInstructions
    });

    // Prepare system prompt
    const baseSystemPrompt = part === 'highlights' 
      ? `You are an expert academic content analyzer. Your task is to analyze the provided lecture content and generate comprehensive highlights by providing content for exactly these six sections with EXACT markdown headers:

## Structure

## Key Concepts

## Main Ideas

## Important Quotes

## Relationships

## Supporting Evidence

IMPORTANT: Use these exact headers and maintain this exact order. Each section MUST have content.`
      : `You are an expert academic content summarizer. Generate a comprehensive summary of the lecture content.`;

    // Adjust the system prompt based on AI configuration
    let systemPrompt = `${baseSystemPrompt}\n\nAdditional Instructions:
- Creativity Level: ${creativityLevel > 0.7 ? 'Be creative and innovative in your analysis' : 'Stay factual and precise'}
- Detail Level: ${detailLevel > 0.7 ? 'Provide comprehensive and detailed explanations' : 'Keep explanations concise but informative'}
- Language: Write in ${contentLanguage}`;

    if (customInstructions) {
      systemPrompt += `\n\nCustom Instructions:\n${customInstructions}`;
    }

    // Make OpenAI API request
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${openAIApiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: lecture.content }
        ],
        temperature,
      }),
    });

    const data = await response.json();
    
    if (!data.choices || !data.choices[0]?.message?.content) {
      throw new Error('No content generated by OpenAI');
    }

    const content = data.choices[0].message.content;
    console.log('Generated content:', content);

    if (part === 'highlights') {
      // Parse the markdown content into sections
      const sections = {
        structure: '',
        key_concepts: '',
        main_ideas: '',
        important_quotes: '',
        relationships: '',
        supporting_evidence: ''
      };

      const contentSections = content.split('##').filter(Boolean);
      
      contentSections.forEach(section => {
        const trimmedSection = section.trim();
        const firstLineBreak = trimmedSection.indexOf('\n');
        const title = trimmedSection.substring(0, firstLineBreak).trim().toLowerCase();
        const content = trimmedSection.substring(firstLineBreak).trim();

        switch (title) {
          case 'structure':
            sections.structure = content;
            break;
          case 'key concepts':
            sections.key_concepts = content;
            break;
          case 'main ideas':
            sections.main_ideas = content;
            break;
          case 'important quotes':
            sections.important_quotes = content;
            break;
          case 'relationships':
            sections.relationships = content;
            break;
          case 'supporting evidence':
            sections.supporting_evidence = content;
            break;
        }
      });

      console.log('Parsed sections:', sections);

      // Store the highlights in the database using upsert
      const { error: upsertError } = await supabaseClient
        .from('lecture_highlights')
        .upsert({
          lecture_id: lectureId,
          ...sections,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });

      if (upsertError) {
        console.error('Error storing highlights:', upsertError);
        throw new Error('Failed to store highlights');
      }

      return new Response(JSON.stringify(sections), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    } else {
      // For full summary, store and return the complete content using upsert
      const { error: upsertError } = await supabaseClient
        .from('lecture_highlights')
        .upsert({
          lecture_id: lectureId,
          full_content: content,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });

      if (upsertError) {
        console.error('Error storing full summary:', upsertError);
        throw new Error('Failed to store full summary');
      }

      return new Response(JSON.stringify({ content }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

  } catch (error) {
    console.error('Error in generate-lecture-summary:', error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});
